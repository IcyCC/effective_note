
....前面不重要...
#  简介

## 术语和定义

* QUIC: 这个协议的名字

* QUIC packet: 一个完整的可处理的 quic 单元, 可以被压缩到一个 udp 报文中, 多个 QUIC packet 可以被压缩进一个 udp 报文

* Ack-eliciting Packet(需要 ack 的包): 一个包含了非 ack, padding, connection_close 的数据包, 会让接受者给一个响应.

* Out-of-order packet(失序包): 一个没有增加最大接受包号的包.

* EndPoint (终端): 一个可以通过 生成, 处理, 接受包参与 quic 链接的东西. 包括客户端服务端.

* Client, Sverer 略

* Address: 一个 (ip_version, ip, udp protocol, port) 元组

* Connection id: 一个用于在一个终端 标记 链接的序号

* Stream: 一个单向 or 双向发送数据的频道, 一个连接可以有多个频道

* Applaication 略


## 标记

\[X]: X是可选的

X(A): X 是 A bit long

X(A/B/C): X长度在 ABC 之中

X(i): X使用长度可变编码2.

X(*): X长度可变
...



# 流

流对应用提供了一个轻量的, 字节序的抽象. 流可以单向或者双向, 比如单向流可以看做一个无限长的消息抽象.


流可以通过发送数据创建, 其他相关过程如流的管理- 如结束, 取消, 管理流控制, 都会竟可能的最小化抽象. 例如, 单个流的帧, 可以打开, 携带数据和关闭流. 流也可以长期生存完整个链接的生命周期.

流也可以被任意一个终端创建, 会和其他的流同时工作, 并可以取消. QUIC 不保证不同流的顺序.

QUIC 允许有任意多的流, 每个流也有任意多的数量的数据, 这个会在 第四节 流程控制 和 流的限制中讨论

## 流的类型和标识

流可以是单向的或者是双向的.

流在一个连接内被数字的编号, 作为流 id. 一个流 id 是 62bit 的整数.流 id 会被以 长度可变编码 方式编码. 每个 id 在一个连接范围内不会被重用.

最后一位是用来表示流的类型.

```

+------+----------------------------------+
| Bits | Stream Type                      |
+======+==================================+
| 0x0  | 客户端发起, 双向  |
+------+----------------------------------+
| 0x1  | 服务端发起, 双向  |
+------+----------------------------------+
| 0x2  | 客户端发起, 单向 |
+------+----------------------------------+
| 0x3  | 服务端发起,单向 |
+------+----------------------------------+

            Table 1: Stream ID Types

```
在一个类型内, 流id会递增的被创建.一个用过的大的 流 ID, 比他小的流 id一定是用过的.

第一个客户端发起的打开的流的 id 为 0

## 发送接收数据

应用数据会被封装在流的帧里.终端会用流 id 和 偏移量 去定位这个消息的顺序.

终端必须可以以有序字节流的方式发送流数据. 按序发送需要终端在公告流程控制范围内缓存失序数据.

QUIC 没有限制发送方字节的顺序, 具体的实现可以提供这个功能.

一个终端可以接受一个流多个相同偏移的数据. 已经接受的会被丢弃, 如果数据不一致会报 PROTOCOL_VIOLATION.

流是一个对 QUIC 没有其他可见结构的有序字节流的抽象, 流的每一帧的边界, 在丢包或者重传的时候, 可以不被保留.(换句话说可以合并)

## 流的优先级

流的多路进行会对性能产生比较大的影响, 要按照正确的优先级来分配资源.

QUIC 没有提供交换优先级信息的机制. 他取决续 QUIC 应用程序的接受优先级.

一个 QUIC 实现 **应该** 提供一个让应用标识流的相对优先级的机制. 当决定流使用那些资源的时候, 实现应该用应用提供的信息.

## 流的必要操作

有一些应用和流交互的时候的必要操作. 本文不提供具体 api, 但是 所有的 quic 实现必须暴露实现以下描述的操作:

发送端:

* write data(写数据), 了解合适进行流量控制保证保存的数据都发送出去
* end the stream (clean termination 安全关闭):由含有 fin标志的流帧触发
*  reset the stream (abrupt termination重置流): 当流没有关闭态, 由RESET_STREAM 帧触发,

接收端:

* 读数据
* 放弃读数据并且请求关闭 一般用 STOP_SENDING 帧触发

应用要知道这些操作的情况, 包括 对端打开或者重置流, 对端放弃读这个流, 新的数据可用, 数据因为流控制可写或者不可写等情况.

# 流的状态

本节用流的发送和接受组件来描述. 有两个状态机:

1. 终端传输数据
2. 终端接收数据

单向流会直接使用合适的状态机. 双向留两个都会用. 大部分时候, 无论单向双向状态机都一样. 双向流的打开条件会复杂一些, 因为两个方向都有打开.

> note: 这些状态信息量很大. 此文档用这些状态来描述 这些不同的帧 如何发送和交互. 尽管这些对实现 QUIC很有用,  但是不会限制具体的实现. 具体的实现可以自己定义状态机..


## 发送时流状态

```

          o
          | 创建流 (发送)
          | 对端创建双向流
          v
      +-------+
      | 就绪   | 发送 RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | 发送 STREAM /              |
          |      STREAM_DATA_BLOCKED  |
          |                           |
          | 对端创建双向流               |
          |                           |
          v                           |
      +-------+                       |
      | 发送   | 发送 RESET_STREAM     |
      |       |---------------------->|
      +-------+                       |
          |                           |
          | 发送 STREAM + FIN         |
          v                           v
      +-------+                   +-------+
      |  数据已 | 发送 RESET_STREAM | 重置已 |
      |  发送  |-----------------> | 发送   |
      +-------+                   +-------+
          |                           |
          | 接收 All ACKs             | Recv ACK
          v                           v
      +-------+                   +-------+
      | 数据以 |                   | 重置已 |
      | 接收  |                    | 接收  |
      +-------+                   +-------+

```

应用打开终端初始化流的发送部分(0和 2 类型是客户端, 1 和 3 类型的服务端). "就绪" 状态代表了一个新创建的可以接受从应用接受数据的流. 流的数据会被缓存然后等待发送.

发送第一个 STREAM 或者 STREAM_DATA_BLOCKED 帧会导致 发送部分进入 "发送" 态. 一个实现可以选择在进入这个状态的时候申请流 id, 这样能更好的按优先级处理(没太理解).

双向流的发送部分是由对端初始化(0 是服务端, 1 是客户端). 当接收端创建完成后会进入"就绪".

在"发送"态. 终端会发送和重发(如果有需求)流的数据. 终端尊重对端设置的的流控制配置. 会接收和好处理 MAX_STREAM_DATA 帧. 一个终端在发送态被流控制控制的时候会发送 STREAM_DATA_BLOCKED帧.

在应用表示 所有的流数据都发送了, 并且一个带有 fin 的 STREAM 也发送了. 流会进入"数据已发送"状态. 在这个状态, 终端只会在需要的时候进行重传.
终端不会检查流控制的限制和发送STREAM_DATA_BLOCKED帧. 当对端收完了所有的数据后,终端才会接受MAX_STREAM_DATA帧. 期间终端会无视所有的MAX_STREAM_DATA.

一旦所有的流数据都被确认了. 流的发送方会进入"数据已接受"状态, 这是终止状态.

当终端在 "就绪", "发送"或者"数据已发送"状态中, 一个应用可以通知他放弃传输. 或者,终端也可能收到对端的STOP_SENDING.  这些情况下, 终端会发送一个RESET_STREAM 并进入 "重置已发送" 态.

一些终端会发送一个 RESET_STREAM 作为流的第一帧.  这会让流的发送部分打开并进入 "重置已发送" 状态.

一旦发送的RESET_STREAM帧被确认. 流的发送部分会进入"重置接收"状态, 这是一个最终态.

## 接收流状态

下图展示了流从对端接收数据的状态. 流的接收的状态 只是一个对对端发送态的一个镜像. 流的接受部分不会跟踪发送流不可观察的部分. 类似 "就绪" 态.取而代之的, 流的接受部分会 最终一些不会被发送端感知的 把数据给应用的过程.


```
          o
          | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
          | Create Bidirectional Stream (Sending)
          | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
          | Create Higher-Numbered Stream
          v
      +-------+
      | 接受   | Recv RESET_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Recv STREAM + FIN         |
          v                           |
      +-------+                       |
      | 了解   | Recv RESET_STREAM     |
      | 大小   |---------------------->|
      +-------+                       |
          |                           |
          | Recv All Data             |
          v                           v
      +-------+ Recv RESET_STREAM +-------+
      | 数据已 |--- (optional) -- >| 重置已 |
      | 接受   |  Recv All Data    | 接受  |
      +-------+<-- (optional) ----+-------+
          |                           |
          | App Read All Data         | App Read RST
          v                           v
      +-------+                   +-------+
      | 数据   |                  | 重置   |
      | 读    |                   | 读    |
      +-------+                   +-------+

              Figure 3: States for Receiving Parts of Streams
```

当收到第一个STREAM,STREAM_DATA_BLOCKED,RESET_STREAM  接受部分的流会被对端初始化(1,3 客户端初始化, 0,2 服务端初始化). 对于被对端初始化的双向流来说, 收到了 MAX_STREAM_DATA 和 STOP_SENDING 也会创建接受部分. 初始化状态是 "接受".

对端的发送流"就绪"状态时, 流的接受部分进入"接受"状态.

终端当收到MAX_STREAM_DATA 或者 STOP_SENDING时会打开打开双向通信. 收到MAX_STREAM_DATA当流未打卡时,
说明对端已经打开并且会提供流控制. 一个未打开的流收到 STOP_SENDING 说明对端不希望接受数据了. 这些帧都会在
STREAM 或者 STREAM_DATA_BLOCKED 前到达, 除非乱序或丢失.

在流创建之前, 所有比流 id 小的流都一定创建完成. 这保证了俩个终端的流创建顺序一致.

在"接受" 状态, 终端会接受 STREAM 和 STREAM_DATA_BLOCKED 帧. 来的帧会被缓存和重排后给上层应用. 数据被消费之后, 这个空间会空出, 终端会发送MAX_STREAM_DATA让对方发送更多的数据..

当一个带有 FIN 标志位的 STREAM帧 接受. 流传输的数据的最终数据就知道了. 接受部分的流会进入 "了解大小" 状态. 在这个状态, 终端不会再发送 MAX_STREAM_DATA, 只会接受重传数据.

一旦所有的数据都收到了, 流会进入 "数据已经接受" 状态. 接受所有数据之后, STREAM 和 STREAM_DATA_BLOCKED 帧会被丢弃.

"数据已接受" 会持续到上层应用读完所有数据. 一旦流的数据都传递结束, 会进入最终态 "数据已读".

在"接受" 和 "了解大小" 状态接收到 RESET_STREAM 帧会进入 "重置已收到" 状态. 这回导致向上层引用传递数据的流程结束.

一旦流被重置的信息传递给了上层应用. 流会进入 "重置已读" 最终状态. 


## 允许的帧类型

流的发送者 会 发送三种帧来影响 双方的状态:  STREAM, STREAM_DATA_BLOCKED , RESET_STREAM

一个发送者在最终态绝对不发送这三种帧. 一个发送者 在 "重置已发送" 和 其他最终态 绝对不会发送STREAM和STREAM_DATA_BLOCKED.
接受者可以随意接受, 因为可能会有的帧晚点到.


接受者会发送 "MAX_STREAM_DATA"和 "STOP_SENDING".
 
接受者只会在 "接受" 态 发送 MAX_STREAM_DATA.  一个接受者可能在未收到RESET_STREAM时发送 STOP_SENDING 也就是 不在 "重置已接收" 和 "重置已读"的状态. 不过在 "数据已接收" 状态发送 STOP_SENDING 没啥价值(所有的帧已经收完了). 一个发送者可以接受  MAX_STREAM_DATA 和 STOP_SENDING 在任何状态.

## 双向流状态

一个双向流会结合了发送者和接受者. 实现要结合这两种流的状态, 最简单的实现就把 open 作为非终止态, close 作为终止态.

表 2 展示了一个复杂的双向流状态映射, 可以粗略的对应督导 http/2. 这展示了多个状态映射到相同的结合态. 注意, 这只是一个可能的实现. 要求在进入"关闭" 或者 "半关闭"状态前, 数据已经被确认.

|  发送部分   | 接受部分  | 组合状态|
|  ----  | ----  | ---- |
| 没有/准备  | 没有/接受 | 闲置
| 准备/ 发送/ 数据已发送  | 接收/了解大小 | 打开
| 准备/ 发送/ 数据已发送| 数据已接受/数据已读 | 半关闭(远程) |
| 准备/ 发送/ 数据已发送| 重置已收到/重置已读 | 半关闭(远程) |
| 数据已接收| 接受/了解大小 | 半关闭(本地) |
| 重置已发送/重置已接收| 接受/了解大小 | 半关闭(本地) |
| 重置已发送/重置已接收| 数据已接受/数据已读 | 关闭 |
| 重置已发送/重置已接收| 重置已接受/重置已读 | 关闭 |
| 数据已接收| 数据已接收/数据已读 | 关闭 |
| 数据已接收| 重置已接受/重置已读 | 关闭 |


### 请求状态转换

假设一个应用不再需要数据. 他可以放弃读数据,然后明确一个特定的应用错误码.

假设流在 "接受" 或者 "了解大小" 状态, 发一个 STOP_SENDING 帧让提示对面及时关闭.
这一般意味着接收端应用不再从流里读数据, 但是不会保证即将到的数据会被无视.

在 STOP_SENDING 之后收到的 STREAM 帧, 仍会进行流控制. 即便这些帧可以扔.

对端收到 STOP_SENDING 后会发送一个 RESET_STREAM 帧. 一个处于"就绪" 或者 "发送"的终端收到 STOP_SENDING 必须发一个
RESET_STREAM. 假如对端处于了"数据已发送", 所有未处理的数据会被声明额为丢弃, 并且终端会用 RESET_STREAM 代替重传.

终端应该从 STOP_SENDING 复制了错误码 放进了他要发送的 RESET_STREAM, 不过可以用别的错误码.
终端可以无视RESET_STREAM发送STOP_SENDING.

STOP_SENDING 仅在未重置的时候可以发送. STOP_SENDING 一般用于 "接受"和"了解大小" 态.

STOP_SENDING 如果丢了会重发, 不过如果这时候终端已经不在 "接受"和"了解大小" 态的话就必要了.

一个终端如果希望结束双向通信的两端, 可以发送一个RESET_STREAM结束一端, 并发送 STOP_SENDING 鼓励对端结束.

# 流控制

为了防止快发送者压跨接受者, 或者防止恶意发送者耗干净接受者内存, 限制接受者可以缓存的数据数量十分重要, 
为了让接受者限制链接内存消耗和给接受者给发送者施加反向力, 所以流控制有整体和独立的. 一个 QUIC 接受者在任意时间
控制能接受的最大数量. 

相似的, 为了限制一个链接内的并发数量, 一个 QUIC 终端可控制对端最大启动流数量.

数据被CRYPTO帧发送会单独处理. QUIC 依赖一个低开销的加密协议实现. 这个实现应该告诉 QUIC 他的缓存限制.

## 数据流控制

QUIC 实现了一个类似 HTTP/2 基于分数的流控制结构, 一个接受者应该告诉他准备的接受的这个链接和这个流的流量. 
所以 qui 的流控制有两个级别.

* 流的流控制. 限制一个流能接受的数量, 防止一个流耗尽了接受者所有的缓存容量. 
* 链接流控制. 限制所有流发送的 STREAM 帧, 防止发送者耗干净一个链接的所有缓存容量.

一个接受者设置了所有流的初始分数, 通过握手时的发送传输参数.
一个接受者通过发送MAX_STREAM_DATA 或者 MAX_DATA 帧给发送者来公告额外的分数.一个MAX_STREAM_DATA帧定义了最大的绝对偏移. 
一个接受者可以使用当前数据消费的偏移去决定宣告的流控制的偏移. 一个接受者为了确保发送者在跑到流控制限制之前收到更新的分数 可以在多个包发送MAX_STREAM_DATA. 
即便其中有包丢了.

一个接受者通过发送MAX_DATA帧公告一个链接的分数, 代表了这个 链接 所有流的 最大绝对偏移的 总和. 一个接受者保存 一个所有流接受数据的总数, 用来检查流控制的冲突.
一个接收者可能使用一个所有流消费的总数来决定公告的最大数据限制.

一个接受者可以通过发送 MAX_STREAM_DATA或者 MAX_DATA 帧公告一个大一些的便宜. 之后接受者发一个小的偏移是不起作用的.

如果发送方违反了所公告的连接或流数据限制，接收方必须以流控制错误错误(第11节)关闭连接。

如果一个发送者违反了流控制限制, 他将不能发送新数据并被阻塞. 一个发送者应该发送 STREAM_DATA_BLOCKED 或者 DATA_BLOCKED帧去 指出 它有数据
去发送但是被流控制限制了. 如果一个发送被阻塞的时间超过了 闲置超时 的限制, 这个链接会关闭即便这时候数据可以发送. 为了不让链接关闭, 一个发送者
应该周期发送 STREAM_DATA_BLOCKED 或者 DATA_BLOCKED 当他没有需要对方 ack 的包在传输的时候.

## 流控制分数增长

实现决定了何时以及多少分数在MAX_STREAM_DATA 和 MAX_DATA 帧公告, 但是本节提供了一些注意事项.

为了避免阻塞发送方，一个接收方可以发送MAX_STREAM_DATA或MAX_DATA多次 或  早一些发以允许从而允许从丢帧里恢复.

控制帧会导致链接的开销增大.  因此, 经常在只有小变动的时候发送MAX_STREAM_DATA 和 MAX_DATA 是不好的. 另一方面, 如果更新
频率比较小, 为了避免阻塞发送方那么限制大一点的增长就很有必要. 这就需要接收方的资源大一些. 这是一个在资源和开销之间的取舍.

一个接受者可以使用自动调节结构来根据接受者的消费速率 和 来往时间 调节发送的控制真频率和分数, 这有点像通用的 tcp 实现. 有一个优化,
一个终端可以只在要发送别的帧 和 对端被阻塞的时候发送流控制帧, 这样可以确保流控制不会发送额外的包.

一个被阻塞的发送者不被要求发送 STREAM_DATA_BLOCKED 和 DATA_BLOCKED帧. 因此一个, 一个接受者不应该等STREAM_DATA_BLOCKED或者DATA_BLOCKED之后才
发送 MAX_STREAM_DATA 和 MAX_DATA. 如果这么做了会导致链接重置. 即便发送者发送了这些帧, 等它的结果也会让发送者至少阻塞一个来回的时间.

当一个阻塞的发送者接收到了分数,它将可能被允许发送更多的数据, 这可能会导致短期拥堵. Section 6.9 会讨论如何避免这个问题.

## 处理取消流

终端要就已经被消耗的流控制分数达成最终一致 来 避免耗尽流控制分数或者死锁.

收到RESET_STREAM帧, 一个终端会删除对应流的状态, 并且无视掉之后到达这个流的数据. RESET_STREAM如果没有偏移信息, 两个终端对链接进行流控制的数据量可能会达成不一致.

为了避免这个问题, 一个RESET_STREAM应该(第19.4节)包括流上发送的数据的最终大小。一旦接受一个RESET_STREAM帧, 接受者可以知道多少数据在 RESET_STREAM 帧 通过这个流发送了, 
并且接受者应该使用最终大小来计算所有发送到这个流的数据来进行他链接的流控制.

RESET_STREAM 会突然中止流的一个方向.对于一个双向流, RESET_STREAM对于对方向的流控制是没用的. 双方必须维护控制另一个方向的流控制状态, 直到这个方向的流结束.

最终大小是流消耗的流控制的分数. 假定所有数据被好好接受, 最终大小就是 发送的数据大小. 更常见的情况是, 最终大小会比发送的数据大一些或者在未发送数据的时候为 0.

一个终端会知道 一个流的 最终大小 当接受部分进入了 "了解大小" 或者 "重置已接收" 的状态. 

一旦知道了流的最终大小, 这个数不会变. 如果 RESET_STREAM 或者 STREAM 会变动这个数, 终端会响应一个 FINAL_SIZE_ERROR 错误. 一个接受者对待在最终大小之后
接收到的数据应该视作一个FINAL_SIZE_ERROR错误, 即便这个流已经关了.  这些错误不是强制的, 他只是告诉终端在流关闭以后维持流控制的状态也是重要的

## 控制并行

一个终端的对端限制了可以打开的流的数量. 只有流的 ID 小于 (最大流 * 4 + 初始的流的类型) 才可以打开.初始的流数量限制可以在传输参数设置, 之后可在 MAX_STREAMS 帧控制.
可以单独的限制适用于单向和双向流.

如果一个最大的流数量限制的参数 或者 收到了 MAX_STREAMS帧的信息大于 2^60, 超过了 variable-length integer可以表示的范围. 会让这个链接关闭, 并报 STREAM_LIMIT_ERROR错.

终端不能超过对端设置的限制. 一个终端收到了超过流 id 的限制的请求, 会关闭连接报 STREAM_LIMIT_ERROR 错.

一旦接受者通过 MAX_STREAMS 公告了 流的限制, 再 公告一个更小的数将不会起做用.

一个因为对端限制无法打开新的流应该发送一个 STREAMS_BLOCKED 帧. 这是一个对调试很有用的事情. 一个终端不应该等收到这个数据后才公告新的限制, 因为会消耗并且不能期待对方一定发这个帧.





