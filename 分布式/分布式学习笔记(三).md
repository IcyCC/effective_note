<!--
 * @Author: your name
 * @Date: 2020-06-10 16:19:25
 * @LastEditTime: 2020-06-11 23:33:46
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /code_note/分布式/分布式学习笔记(三).md
--> 
# 科班分布式学习(三)-  一致性和Zookeeper & CRAQ

## Zookeeper

> 这个没太看懂要阐述的知识点, 都是系统设计和使用上的, 所以提出里面的一致性做个讨论

zookeeper 这里保持共识的 zab 协议和 raft 很像.

zookeeper 这论文的讲了两点:

1. zookeeper 的一致性
2. 一种类似文件系统的 api 设计

通过一致性保证和 api 构造锁等分布式常见业务

### 分布式一致性

zk 写情况下是线性一致性, 读写情况下是顺序一致性. 那这些一致性是什么意思.

我们把复制数据之间的同步叫一致性, 一般来说 我们有以下一致性模型(参考维基百科的版本 网上版本较多):

#### 线性一致性

首先是强一致性模型,我们也称 **线性一致性(Linearizable Consistency)**:

要求如下:

1. 任何一次读都能读到最近写入的值 
2. 对于所有 client 其像按照统一的时间串行的执行了这些操作

这个要求的意思就是, 比如有 a,b 两个节点

```
a: A------B
b: ----C-----D
```

分别执行 ABCD, 并行执行, 那么最终落盘的顺序就是 ACBD 严格按照某个时钟顺序来

#### 顺序一致性

有一种比强一致性稍微弱一些的一致性, 叫 **顺序一致性**

要求:

1. 执行指令为编程顺序,不同client 没有严格的顺序要求
2. 对所有节点来看整个系统是一个单一的顺序

这个要求的意思就是 还是 ab,

```
a: A------B
b: ----C-----D
```

那么落盘的顺序可以是 ABCD 也可以 CABD....但是 不能 BADC这样不按照编程顺序, 而且如果确定了 ABCD那么所有节点读到的顺序都是 ABCD

想比较强一致性, 该要求少了对不同节点相同时间顺序的要求


### 因果一致性

这个要求比较好理解, 他要求有因果关系的操作的顺序一致即可:

比如 ab 节点:

```
a: A------B(C)
b: ----C-----D
```

这里 B对 C有依赖 B 一定在 C 的后面, 但是对于 AD 没有任何要求.只要满足 B 在 C 的后面的顺序都可以,对于别的节点读取也不做要求

在 zookeeper 里, 写操作都是线性一致性, 客户端通过 fifo 来保证顺序一致性


** 其余部分没有看出论文要阐述的设计的点 **

> 有一些讲了怎么用 api 做锁啥的 思路太直接了 不做讨论

## CRAQ

论文首先介绍了一个简单的强一直性的系统设计: **链复制**

![](https://gitee.com/IcyCC/PicHouse/raw/master/assests/20200611222327.png)

这是一个链表, 写请求写在链表头, 读请求在链表尾巴.

写请求来了, 会逐个向后传播, 并且此时这个数据的状态是 未提交, 
等到传到了末节点, 才会提交这个修改, 并且提交的确认信息向前传播.

而读取只能从尾结点读取. 读取到的一定是已经达成了一致的消息.

### 故障

* 头结点挂 提交确认消息 没有到 不影响一致
* 尾结点宕机, 新成为尾结点的节点提交自己
* 中间节点宕机 没影响

然后因为业务普遍读多写少,而这样容易有读瓶颈, 所以提出了 **分配查询链复制**

![](https://gitee.com/IcyCC/PicHouse/raw/master/assests/20200611230548.png)

写请求还是写在 头结点, 写的时候带一个版本号, 版本号初始化为dirty 状态, 然后传播写到尾结点, 尾结点把这个版本标记成 clean 再反向传播.

而读的时候, 可以 如果是 clean 直接返回, 如果不是,就向最后一个节点问最新的版本号, 把这个版本号的数据返回.

针对读多写少这个方案很划算, 如果写多的话会常常读到 dirty 版本导致效率下降, 但是因为只读一个版本号, 对尾结点负担还是比较 *链复制CR* 小.


此外通过细小的变化可以支持多种一致性模型:

* 强一致性模型, 之前聊得都是.

* 最终一致性  读的时候直接返回最新的版本就行, 这样会破坏读取的单调性

* 最大边界的最终一致性 返回最新的, 但是说明这是多少时间以内的不一致

对比 Raft

Raft 只要半数, CR 需要等节点逐个传递, 万一不可用要等

后面是一些实践的内容了 不做过多讨论.

## 参考文献

[1] https://iswade.github.io/translate/zookeeper zookeeeper 论文翻译  

[2] https://pdos.csail.mit.edu/6.824/papers/craq.pdf crqa 论文  

[3] https://en.wikipedia.org/wiki/Consistency_model 一致性模型 wiki

[4] https://zhuanlan.zhihu.com/p/57315959 一致性模型