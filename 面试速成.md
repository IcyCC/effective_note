
# auto_ptr unique_ptr 区别

auto_ptr 的复制是移动语义, unique_ptr 禁用了copy


 # select/poll/epoll 对比

1. 调用select时， 用户空间拷贝fd_set 进入内核中, *遍历*fd看看是不是有时间发生, 最大数量收到fd_set_size限制(1024)
2. poll 把fd_set使用链表存 没了最大数量限制, 他们都是水平触发
3. epoll  (1)通过epoll_ctl 在注册时就拷贝到内核, 减少了拷贝 (2) 内核会把发生事件的fd, 通过回调的方式放入就绪队列, 调用epoll_wait拷贝回用户空间, 可以选择触发模式

# mongodb 场景

无需事务和跨表查询, 大量文本查询, 业务变动频繁

# mmap

mmap是内存对磁盘的一个映射, 用于减少拷贝, 原理通过虚拟空间中的一个空间, 作为物理文件的缓存, 未命中的时候读取. 匿名的版本常用作分配连续大块内存

# std::move干了什么

做了个强制类型转换 左值转换成右值

# dup 或者 fork 文件描述符怎么样了? 

共享一个文件表项, pcb文件描述符表复制. 文件描述符引用计数

# 黏包

没必要管 应用协议自己处理


# 构造函数 析构函数 虚函数

构造函数不能是虚函数, 在构造过程中要确定虚表 即 vfptr 指针
析构函数建议是虚函数, 要清理资源

# 惊群

多个进程阻塞等待操作系统信号的时候, 被操作系统虚假唤醒, 现在操作系统内核负载均衡了, 没这个问题, so_reuseport, 或者通过锁来添加listen_fd

# linux查看栈的大小

ulimit -s

# Proactor 和 Reactor

Reactor 就绪了自己写, Proactor 写完了给通知

# 滑动窗口

保证顺序, 限制速率, 缓存区大小

# git rebase

# time_wait过多

开启 tcp_tw_recycle(关键快速销毁) tcp_tw_reuse tcp_timestamps

# stl迭代器

input_iterator output_iteraotr forward_iteroator bidrectional_iterator random_access_iterator vector 

vector deque 是随机迭代器 list 双向迭代器  stac_queue priority_queue 没迭代器 
set map 双向迭代器 unordered 前向迭代器 

顺序容器, 插入删除回失效, 关联容器删除会失效


# redis 过期

redisDB 对象有 dict 和 expires 

redis 默认 1秒 10 次过期检查, 随机 20 key, 删除过期的, 超过 1/4 再次检查,
从库不检查, 只等主库删除

用户对 key 访问的时候会检查过期, [代码](https://github.com/antirez/redis/blob/d984732b3517dae198422080a6adf0cc96c1dd92/src/db.c#L104)

删除任务会放在另一个线程中执行

当内存满时可以选择过期策略 lru lfu












