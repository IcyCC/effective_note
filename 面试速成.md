
# auto_ptr unique_ptr 区别

auto_ptr 的复制是移动语义, unique_ptr 禁用了copy


 # select/poll/epoll 对比

1. 调用select时， 用户空间拷贝fd_set 进入内核中, *遍历*fd看看是不是有时间发生, 最大数量收到fd_set_size限制(1024)
2. poll 把fd_set使用链表存 没了最大数量限制, 他们都是水平触发
3. epoll  (1)通过epoll_ctl 在注册时就拷贝到内核, 减少了拷贝 (2) 内核会把发生事件的fd, 通过回调的方式放入就绪队列, 调用epoll_wait拷贝回用户空间, 可以选择触发模式
4. 水平触发, 一直触发, 边缘触发, 触发一次

# mongodb 场景

无需事务和跨表查询, 大量文本查询, 业务变动频繁

# mmap

mmap是内存对磁盘的一个映射, 用于减少拷贝, 原理通过虚拟空间中的一个空间, 作为物理文件的缓存, 未命中的时候读取. 匿名的版本常用作分配连续大块内存

# std::move干了什么

做了个强制类型转换 左值转换成右值

# dup 或者 fork 文件描述符怎么样了? 

共享一个文件表项, pcb文件描述符表复制. 文件描述符引用计数

# 黏包

没必要管 应用协议自己处理


# 构造函数 析构函数 虚函数

构造函数不能是虚函数, 在构造过程中要确定虚表 即 vfptr 指针
析构函数建议是虚函数, 要清理资源

# 惊群

多个进程阻塞等待操作系统信号的时候, 被操作系统虚假唤醒, 现在操作系统内核负载均衡了, 没这个问题, so_reuseport, 或者通过锁来添加listen_fd

# linux查看栈的大小

ulimit -s

# Proactor 和 Reactor

Reactor 就绪了自己写, Proactor 写完了给通知

# 滑动窗口

保证顺序, 限制速率, 缓存区大小

# git rebase

# time_wait过多

开启 tcp_tw_recycle(关键快速销毁) tcp_tw_reuse tcp_timestamps

# stl迭代器

input_iterator output_iteraotr forward_iteroator bidrectional_iterator random_access_iterator vector 

vector deque 是随机迭代器 list 双向迭代器  stac_queue priority_queue 没迭代器 
set map 双向迭代器 unordered 前向迭代器 

顺序容器, 插入删除回失效, 关联容器删除会失效


# redis 过期

redisDB 对象有 dict 和 expires 

redis 默认 1秒 10 次过期检查, 随机 20 key, 删除过期的, 超过 1/4 再次检查,
从库不检查, 只等主库删除

用户对 key 访问的时候会检查过期, [代码](https://github.com/antirez/redis/blob/d984732b3517dae198422080a6adf0cc96c1dd92/src/db.c#L104)

删除任务会放在另一个线程中执行

当内存满时可以选择过期策略 lru lfu

# Mysql 并发

## 一致性问题

* 丢失修改: A修改完, B修改, A再读, 修改没了
* 脏读: A修改了, B读了, A*异常*撤销, B读到了脏数据
* 不可重复读: A修改 B读 A再修改, B再读 不一致
* 幻读: B在读某个范围, A插入某个范围的数据,  B在读 不一致

## 读写锁

## 意向锁

为了解决给表加锁需要检查有没有行有锁

## 封锁协议

* 一级: 修改数据加写锁, 事务结束去锁, 可以解决丢失更新
* 二级: 一级, 读数据加写锁, 读完马上释放, 可以解决脏读 因为不可能边更新边读
* 三级: 二级, 读锁事务结束释放, 解决不可重复读

## Mysql隔离级别

* 读未提交  
* 读提交 : 每次更新的时候创建快照
* 可重复读:  每次事务开始的时候创建快照
* 可串行化: 加锁

## mvcc
快照: 事务开始前会创建快照, 在读提交级别下, 每次读都会创建这个快照, 可重复读的时候, 会加锁, 更新的读都是当前读, 会读到最新的已经提交的版本

回滚: 快照 + 回滚日志

# mysql 日志

## bin log

逻辑日志, 一直增加, mysql 提供: 
记录了
1. 主从同步
2. 恢复数据

## redo log

物理日志, 记录物理的写入, 硬盘上, 用于快速的恢复, 和缓存
innodb 提供

俩段式提交


## undo log

事务修改的链条, 快照根据 undoo log 计算

# 读写分离
方案: 
 1. 客户端 proxy
 2. 服务发现

主备延时:
1. 业务处理, 不能过期读的走主库
2. 延时 1s ajax 假增加
3. semi-sync 半同步, 从库同步完成发 ack 才能结束事务



# read-copy-update

更新的发现别人读的时候复制副本, 对副本修改, 没人读了更新


# b 树和b+树

1. b+树不保存数据, 更矮胖
2. b+树要匹配到叶子节点
3. 范围查询支持

# TCP 握手

握手: 

 * 客户端: SYN_SENT -syn i -> ESTABLISHED
 * 服务端: SYN_ RCVD - syn k, ack i+1 --> ETABLISHED

 服务端 调用 listen 进入  listen. 客户端调用 connect, 发送 SYN, 进入 SYN_SENT. 服务端接受 SYN 进入 SYN_RCVD , 并返回 ACK 和 SYN. 客户端接受 SYN+ACK 进入 ETABLISHED 并发送 ACK, 服务端接受 ACK, 把链接放入就绪队列


 
挥手:

* 客户端: FIN_WAIT_1 -fin m -> FIN_WAIT2 - ack n+1 -> TIME_WAIT
* 服务端: CLOSE_WAIT -ack m +1> LAST_ACK - fin n -> CLOSE

客户端发送 fin 进入 FIN_WAIT_1. 服务端接受 fin 进入 CLOSE_WATI, 返回 ack, 并准备发送剩余的数据. 客户端接受到 ack, 进入 fin_wait2. 服务端发送完成了, 发送 fin 给客户端, 进入 lack_ack. 客户端收到 fin 进入 time_wait, 发送 ack. 服务端收到 ack 关闭


问题:

1. 和不存在的端口链接: 收到 SYN 发现某个端口没运行, 直接返回 RST
2. 和不存在的主机链接, 发送 SYN 没回应, 6s 后重发...超时,可以 connect 设置超时时间
3. server 阻塞, 链接正常建立, 发送正常, 就是不会有响应
4. server 宕机, 不会收到, 会一直重发然后返回ETIMEDOUT
4. server 宕机重启, 收到了错误的包, 直接发 RST

## TCP优化

* tcp_syncookies # 防止syn攻击, 用 cookie 表示链接
* tcp_tw_reuse # TIME_WAIT 套接字可以用于新的链接
* tcp_tw_recycle # 快速回收 TIME_WAIT
* tcp_timestamps # 时间戳开启, 用于 time_wait 的套接字
* tcp_max_tw_buckets # time_wait 套接字数量


## 套接字优化

* SO_KEEPALIVE 长链接
* SO_NODELAY 禁止 nagle 算法
* SO_LINGER 优雅关闭 0 立刻返回, 发送完剩下的数
* SO_REUSEADDR time_wait 直接启动
* SO_REUSEPROT 内核负载均衡

# 页面置换

* FIFO
* LRU
* LFU
* CLOCK: 循环队列, 指针指向最后的记为, 置换的时候 判断最近的访问次数, 如果 0 直接淘汰, 其他情况置为 0 淘汰

# 限流算法

* 窗口: 一个时间只允许固定的流量
* 令牌桶: 一个放令牌, 一个拿令牌, 桶有容量限制
* 漏斗: 队列


# redis 数据结构和优化

* 列表: 元素少压缩链表 用连续内存, 和数据的偏移, 大小, 长度, 元素多用压缩链表, 多个链接只有一个下一个指针
* zset: 跳跃表
* dict: 俩个哈希表, 用来渐进式rehash, 
* set: 一个 dict
* sds: 小字符串压缩存储


# docker 网络模式

* bridge 网桥 一个单独的主机内 ip, 通过虚拟网卡通信
* host  共享主机的 ip

# mysql 联合索引范围查询

先查 等值 再查范围, 因为[A,b] A一样了 b 就是有序的了

# 海量数据问题:

## 10 亿个 ip/ 10 亿个年龄 

桶排序,

## 最高频率

哈希分流成不同小文件, 每个小文件找贵高的, 再比对


## top k 

哈希分流 + 小根堆 + 外排序


## golang 反射 and c++ rtti

golang:
可以反射接口类型, 可以修改反射对象

## http 301, 302 永久 临时重定向

## 文件系统

* inode 一个文件
* dentry 目录
* 文件表 打开的文件的列表
* 硬连接 创建一个目录
* 软连接重定向



#nginx

## 反向代理

upstream localtion prox_pass

## 负载均衡

poxy_pass http://upstream_name

## IP

proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;


# linux 后台进程

* nohup 一直运行 进程被托管 不是后台运行!!! 忽略SIGHUP信号
* & 后台运行 结尾添加, 忽略 SIGKILL
* jobs 可以查看后台进程
* fg 讲后台进程放入前台, 
* ctrl+z 讲任务挂起, 使用 fg, bg 启动 发送 SIGTSTP
* ctrl+c 结束任务 发送SIGTSTP
* ctrl+d 发送 EOF

# redis 单个 value 过大

# 非阻塞套接字 阻塞套接字大 io

