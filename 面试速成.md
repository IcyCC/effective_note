
# auto_ptr unique_ptr 区别

auto_ptr 的复制是移动语义, unique_ptr 禁用了copy


 # select/poll/epoll 对比

1. 调用select时， 用户空间拷贝fd_set 进入内核中, *遍历*fd看看是不是有时间发生, 最大数量收到fd_set_size限制(1024)
2. poll 把fd_set使用链表存 没了最大数量限制, 他们都是水平触发
3. epoll  (1)通过epoll_ctl 在注册时就拷贝到内核, 减少了拷贝 (2) 内核会把发生事件的fd, 通过回调的方式放入就绪队列, 调用epoll_wait拷贝回用户空间, 可以选择触发模式
4. 水平触发, 一直触发, 边缘触发, 触发一次

# mongodb 场景

无需事务和跨表查询, 大量文本查询, 业务变动频繁

# mmap

mmap是内存对磁盘的一个映射, 用于减少拷贝, 原理通过虚拟空间中的一个空间, 作为物理文件的缓存, 未命中的时候读取. 匿名的版本常用作分配连续大块内存

# std::move干了什么

做了个强制类型转换 左值转换成右值

# dup 或者 fork 文件描述符怎么样了? 

共享一个文件表项, pcb文件描述符表复制. 文件描述符引用计数

# 黏包

没必要管 应用协议自己处理


# 构造函数 析构函数 虚函数

构造函数不能是虚函数, 在构造过程中要确定虚表 即 vfptr 指针
析构函数建议是虚函数, 要清理资源

# 惊群

多个进程阻塞等待操作系统信号的时候, 被操作系统虚假唤醒, 现在操作系统内核负载均衡了, 没这个问题, so_reuseport, 或者通过锁来添加listen_fd

# linux查看栈的大小

ulimit -s

# Proactor 和 Reactor

Reactor 就绪了自己写, Proactor 写完了给通知

# 滑动窗口

保证顺序, 限制速率, 缓存区大小

# git rebase

# time_wait过多

开启 tcp_tw_recycle(关键快速销毁) tcp_tw_reuse tcp_timestamps

# stl迭代器

input_iterator output_iteraotr forward_iteroator bidrectional_iterator random_access_iterator vector 

vector deque 是随机迭代器 list 双向迭代器  stac_queue priority_queue 没迭代器 
set map 双向迭代器 unordered 前向迭代器 

顺序容器, 插入删除回失效, 关联容器删除会失效


# redis 过期

redisDB 对象有 dict 和 expires 

redis 默认 1秒 10 次过期检查, 随机 20 key, 删除过期的, 超过 1/4 再次检查,
从库不检查, 只等主库删除

用户对 key 访问的时候会检查过期, [代码](https://github.com/antirez/redis/blob/d984732b3517dae198422080a6adf0cc96c1dd92/src/db.c#L104)

删除任务会放在另一个线程中执行

当内存满时可以选择过期策略 lru lfu

# Mysql 并发

## 一致性问题

* 丢失修改: A修改完, B修改, A再读, 修改没了
* 脏读: A修改了, B读了, A*异常*撤销, B读到了脏数据
* 不可重复读: A修改 B读 A再修改, B再读 不一致
* 幻读: B在读某个范围, A插入某个范围的数据,  B在读 不一致

## 读写锁

## 意向锁

为了解决给表加锁需要检查有没有行有锁

## 封锁协议

* 一级: 修改数据加写锁, 事务结束去锁, 可以解决丢失更新
* 二级: 一级, 读数据加写锁, 读完马上释放, 可以解决脏读 因为不可能边更新边读
* 三级: 二级, 读锁事务结束释放, 解决不可重复读

## Mysql隔离级别

* 读未提交  
* 读提交 : 每次更新的时候创建快照
* 可重复读:  每次事务开始的时候创建快照
* 可串行化: 加锁

## mvcc
快照: 事务开始前会创建快照, 在读提交级别下, 每次读都会创建这个快照, 可重复读的时候, 会加锁, 更新的读都是当前读, 会读到最新的已经提交的版本

回滚: 快照 + 回滚日志

# mysql 日志

## bin log

逻辑日志, 一直增加, mysql 提供: 
记录了
1. 主从同步
2. 恢复数据

## redo log

物理日志, 记录物理的写入, 硬盘上, 用于快速的恢复, 和缓存
innodb 提供

俩段式提交

# 读写分离
方案: 
 1. 客户端 proxy
 2. 服务发现

主备延时:
1. 业务处理, 不能过期读的走主库
2. 延时 1s ajax 假增加
3. semi-sync 半同步, 从库同步完成发 ack 才能结束事务



# read-copy-update

更新的发现别人读的时候复制副本, 对副本修改, 没人读了更新


# b 树和b+树

1. b+树不保存数据, 更矮胖
2. b+树要匹配到叶子节点
3. 范围查询支持

# TCP

握手: 

 * 客户端: SYN_SENT -syn i -> ESTABLISHED
 * 服务端: SYN_ RCVD - syn k, ack i+1 --> ETABLISHED

 服务端 调用 listen 进入  listen. 客户端调用 connect, 发送 SYN, 进入 SYN_SENT. 服务端接受 SYN 进入 SYN_RCVD , 并返回 ACK 和 SYN. 客户端接受 SYN+ACK 进入 ETABLISHED 并发送 ACK, 服务端接受 ACK, 把链接放入就绪队列


 
挥手:

* 客户端: FIN_WAIT_1 -fin m -> FIN_WAIT2 - ack n+1 -> TIME_WAIT
* 服务端: CLOSE_WAIT -ack m +1> LAST_ACK - fin n -> CLOSE

客户端发送 fin 进入 FIN_WAIT_1. 服务端接受 fin 进入 CLOSE_WATI, 返回 ack, 并准备发送剩余的数据. 客户端接受到 ack, 进入 fin_wait2. 服务端发送完成了, 发送 fin 给客户端, 进入 lack_ack. 客户端收到 fin 进入 time_wait, 发送 ack. 服务端收到 ack 关闭

