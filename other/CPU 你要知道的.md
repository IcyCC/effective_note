# 关于 CPU 你要知道的--并发和 Cache

> 本文旨在用人话解释一些概念, 快速让你知道这些概念的意思, 不做深入研究.

CPU 一条指令的主要的工作流程 是 :

取指令 -> 译码 -> 执行 -> 访存 -> 写回 -> 更新程序计数寄存器 

每一个步骤需要一个时钟周期.

而现代 cpu 加速的思路, 也是从这几个步骤下手:

1. 通过缓存 加快 准备数据的流程
2. 执行指令的时候 同时让多条指令运行
3. 写回结果的时候, 保证数据的同步

我们先不管 cache 看看同时多条指令运行的办法有哪些

## 多条指令执行--流水线, 多发射, 超线程, SIMD

### 流水线 

正常情况下 我们执行指令是这样的:

![](https://gitee.com/IcyCC/PicHouse/raw/master/assests/20200229170505.png)

我们可以把一个指令分到多成多个步骤, 这样前一个步骤做完空闲了就可以处理别的指令.

比如 我们把一个指令 分成 1,2,3 三步, 当做到 2 步的时候, 负责 1 的流水线就空闲了, 可以处理下一个指令的 1, 类似下图
![](https://gitee.com/IcyCC/PicHouse/raw/master/assests/20200229170701.png)

而不采用流水线, 只能一次执行完一整条指令.

流水线也有副作用, 引入流水线, 要把上一道工序的结果暂存供下一道工序时候, 会有一些额外的开销.


流水线的核心目的, 是想 **要每次能取指令的时候(一个时钟周期)** 都可以取出来指令.

### 多发射 

多发射指 利用复制相同功能的单元, 并行的执行多条指令.

这个 首先会一次拿多个指令, 然后会并行的译码执行,

因为 即使有流水线的存在, 如果一个周期只能取一条指令, 那么这个 Cpu 的一个时钟能执行的指令数还是 1 , 同时取多个就可以超过 1 了.

多发射技术有俩种模式, 如果是编译代码的时候, 进行多发射的调度, 也可以动态的进行多发射调度, 后者这种方式叫做( **超标量**)

流水线和多发射是所谓的 **指令级并行** 当然, 这里也存在很多问题: 

1. 要同时发射那些指令才不会出问题?
2. 指令之间互相存在依赖怎么办?

这个稍后会解决.

### 超线程

超线程的思路是这样的: 

1. 我们可以找出一组不会互相有依赖的指令, 比如俩个程序的指令 可以方便的让他们并行执行
2. cpu 中有俩种硬件, 一种是一个程序执行就会一直占用的硬件(程序计数寄存器, 指令寄存器,条件码寄存器 ), 
另一种是可能会空闲的, 比如ALU 单元, 一个程序不计算执行别的过程时, 会空闲, 所以只有重复很少的一直占用的单元, 就可以实现并行执行的效果

最终效果这样.

![](https://gitee.com/IcyCC/PicHouse/raw/master/assests/20200229181734.png)

通过少部分硬件的重复并行利用大部分重复的硬件


### SIMD 单指令多数据流

这是一套和硬件配套的指令集, 需要编程的时候使用特定的指令,

简单的说, 就是一条指令, 可以同时取多个数据, 同时算多个数据.

### 冒险和预测--解决流水钱和多发射的问题

无论流水线还是多发射, 本意都是让指令并发的执行, 一但并发, 就存在几个问题:

1. 资源的竞争 我们这里成为 **结构冒险**
2. 数据的依赖  成为 **数据冒险**
3. 可以并发哪些  称为 **控制冒险**

#### 结构冒险

当我们几条指令在*一个发射的流水线上执行的时候*, 在某个特定的时钟周期, 某两个指令都需要竞争一个结构资源, 比如主存

典型情况:
![](https://gitee.com/IcyCC/PicHouse/raw/master/assests/20200229214027.png)

我们称这种情况为结构冒险.

#### 数据冒险

数据冒险就是同时指向多个指令的时候, 存在数据的依赖:

根据依赖的情况, 可以分为:

1. 先写后读

```
a = a + 1
b = a + 3
```

这个情况要等 第一句把新的 a 的值写回才能执行下一句

2. 先读后写

```
a = b + 2
b= a + b
```

读取 b 的值, 才能 执行第二句的写入

3. 写后再写

```
a = 1
a = 2
```

必须先写后一句再写前一句


#### 控制冒险

流水线和多发射中, 要求上一条指令没完就要取下一条指令, 取那条指令就是一件很难判断的事

```
1: if a:
2:   ....
3: else:
4:   ....

```

比如这种情况, 需要 根据 1 的结果, 才能决定下一条并行 2还是4

为了解决上述问题, 我们想到了一些解决方案:

#### 增加资源

现代 cpu 会采用混合架构, 把内存分为数据缓存和指令缓存, 这样取指令和读存的两个指令, 就不会冲突了.

类似的, 结构冒险都可以考虑用增加资源的办法

### 指令对齐

由于指令的长度不一样, 流水线进行排序的时候 会出现这样的情况, 先开始的长指令. 和后开始的短指令, 同时指向到一个步骤, 比如写回内存, 产生了对同一资源的竞争, 比如, 


![](https://gitee.com/IcyCC/PicHouse/raw/master/assests/20200229215408.png)

我们可以对指令的长度进行填充, 插入 NOP(什么都不干), 让他们一样长来避免这个问题.

#### 停顿

当发生依赖的时候, 我们可以通过在这个周期什么都不干 ,来等待锁依赖的数据就绪, 这个有点像并发编程轮询的办法


#### 操作数前推

这是一种可以减少停顿时间的办法,

```
1: add $t0, $s2,$s1
2: add $s2, $s1,$t0
```

比如这样的代码, 理论上说, 代码 2 要等到代码 1 将结果写回才可以进入执行阶段, 

通过一些硬件上的构造, 我们可以把代码 1 *执行*阶段的结果直接发送给代码 2, 而不用等 1 *写回* 完成.

#### 乱序执行

我们可以把解释好的指令存起来, 放到一个地方, 等满足依赖条件直接畅通无阻的发出去, 再搜集好结果排成原来的顺序

![](https://gitee.com/IcyCC/PicHouse/raw/master/assests/20200229220224.png)


#### 分支预测

就是猜猜下一个可能的指令是什么, 来解决控制冒险, 猜错了就再卡住执行对的


## 加快存取速度--缓存

冯诺曼依瓶颈: cpu 执行代码的速度远远快于从主存取数据

### 通用的结构


会分成组, 组里有行, 每行会对应内存中的一个数据,  有一个有效,标记 和数据, 首先 加载数据的单位是 2^b 
![](https://gitee.com/IcyCC/PicHouse/raw/master/assests/20200229232601.png)



有效位, 用来判断这个缓存是不是 dirty, 

根据索引, 查到组, 组内部找到 标记 相同的行, 说明这行的数据是缓存, 缓存了2^b个, 利用后 b个位的数字的 偏移就可以找到具体的数据

![](https://gitee.com/IcyCC/PicHouse/raw/master/assests/20200229233031.png)


也就是说 一个行对应的是 所有 **组索引** 相同的数据内存, 根据 **标记** 看看存的是不是对应的一块, 通过 **块偏移拿到具体数据**

我们可以根据通用结构的特例, 找到几种不同的链接方式:

1. 直接映射 每个组只有一行
2. 组关联 有多个组 每个组多行
3. 全相连 只有一个组


### 写入策略

读没什么问题, 问题是写, 写了一个 缓存行, 什么时候把这个行写回主存? 

1. 写直达 write-through

核心思想就是数据一定要阻塞的写回内存. 如果缓存命中, 就写缓存, 然后等缓存写回主存, 才能完成这次

2. 写回 write-back

写回策略的核心 是 延迟写入,  当一个缓存行要被替换掉的时候才写回到 ram 中.

![](https://gitee.com/IcyCC/PicHouse/raw/master/assests/20200301000134.png)


### 多核缓存一致性 和 MESI协议

满足能让多核缓存一致的办法 有俩个理论条件;

1. 写传播, 写入的信息可以传播到别的 cpu 核心

2. 事务串行化, 每个核心看对一个缓存的操作的顺序都是一样的, 反例:

![](https://gitee.com/IcyCC/PicHouse/raw/master/assests/20200301001119.png)



## MESI协议

MESI 是 M(修改) E(独占) S(共享) I(失效的缩写)的缩写, 当发现缓存被共享且要写入的时候, 会广播一个写失效的消息. 标记别的核心的缓存失效.

为了节约广播的信息, MESI协议会监听别的 cpu 对内存的读取信息,  第一次获取这个内存, 会把内存信息标记成独占, 如果监听到了其他读内存的信息, 就改成共享, 对共享的修改 要传播给其他核心失效. 思路想读写锁.


## 小结

学习计算机的本质是复读机,  这里出现的思路, 都是在更高层级的地方不断出现的内容, 从各个层级不断复读这些思路, 从而多角度的理解, 这可能是业务码农学习底层原理的一个用处吧.


参考资料:

[1]. 极客时间 深入浅出计算机组成原理.  http://gk.link/a/10gq7  
[2]. <深入理解计算机系统>.  
[3]. <并行程序设计导论>.  