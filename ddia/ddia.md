
# 数据复制

## 主从复制:
只有主节点可写的

## 同步和异步复制
是否等从节点确认

## 不停机配置新的从节点流程:
1. 对主节点进行一致性快照
2. 快照到新节点
3. 向主节点请求快照点位置之后所有日志
4. 进行处理

## 节点切换
1. 确认失效
2. 选举新的主节点
3. 配置新的节点
问题:
1. 异步复制, 新节点成为主节点时, 旧节点比新节点数据新. 旧节点给新节点同步数据冲突. 
2. 基于问题 1, 如果丢弃数据会导致外部系统不一致. 如同一个 key 的数据缓存和 db 不一致.
3. 两个节点同时成为主节点 发生脑裂
4. 如何检测主节点失效?

## 复制日志的实现

1. 语句级别: 存在非确定函数, 自增列数据, 副总用函数的问题
2. wal 日志: 泰国底层, 贴近物理描述
3. 逻辑日志: 解耦逻辑日志和物理日志

## 复制滞后

写后读一致性
* 强制从主节点
* 记录更新时间, 看时间范围决定是否从主节点读

## 单调读
用户看到的值不会比之前看到的值更旧， 实现用哈希到固定的分库

## 一致前缀读
由于不同分区延迟不同 导致写入的前后不同破坏了因果性
要保证因果性相关的写入一个分区。

## 多主复制

问题： 多主写入的数据冲突。
* 避免冲突 通过路由让一个用户的数据只访问一个主
* 收敛到一致 例如 保留最后一个方式 或者 记录流水业务处理
* 自定义业务冲突 写执行 读执行

拓扑结构：
1. 环状 2. 星型 3. 全连接

## 无主复制

核心思想： 法定人数 多份写入 多份读


# 数据分区

## 分区方法

* 关键字区间: 支持高效查询, 哈希分区
* 哈希分区: 分布均匀.

## 二级索引

基于文档: 每个分区独立 便于写入
基于词条: 便于读取

## 分区平衡

取模: 会导致每次扩展都有很多 key 需要迁移
固定数量分区: 把分区数量定高, 之后再平衡分区, key 的计算分区是固定的, 只会动这些分区.
动态分区:  类似一致性哈希的思想

## 请求路由
* 中心化调度: zookeeper
* gossip: 类似路由协议 每个节点负责转发

## 事务



